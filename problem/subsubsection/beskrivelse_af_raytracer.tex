\subsubsection{Beskrivelse af raytracer}
I dette afsnit vil de væsentlige funktioner til raytraceren blive beskrevet. Formålet med afsnittet er, at få en forståelse for hvordan den tidligere beskrevet teori, \ref{sec:teori}, er anvendt og håndteret i programudviklingen.


\paragraph{Rendering}
For at rendere et billede af lampen og dens belysning, er der lavet en funktion raytracer\_render, der modtager scenen, dvs. samlingen af alle 3D-objekter og lys, samt modellen for det kamera, som billedet skal dannes ud fra. Funktionen er vist herunder.

\begin{lstlisting}[style=Cstyle, caption=Funktionen der rendere billedet af scenen med et kameras perspektiv]
Image *raytracer_render(Scene *scene, Camera *camera) {
  int x, y;
  Image *image;
  Ray ray;

  image = new_image(camera->width, camera->height);
  
  /* For each column: */
  for(x = 0; x < camera->width; x++) {
    /* For each pixel in column: */
    for(y = 0; y < camera->height; y++) {
      /* Calculate ray */
      ray = raytracer_calculate_ray(x, y, camera);
      
      /* Trace ray and assign result to pixel */
      image->pixels[x][y] = raytracer_trace(ray, scene);
    }
    printf("%.1f\n", ((double)x + 1) / camera->width * 100);
  }

  return image;
}
\end{lstlisting}

Funktionen vist herover, danner en lysstråle for hver pixel i billedet. lysstråle sendes videre sammen med scenen til funktionen raytracer\_trace, som returnere hvilken farve den pågældende pixel på billedet skal have. Til sidst returneres så det endelige billede.

\paragraph{Tracer}
Funktionen raytracer\_trace er den funktion som starter raytraceren samt returnerer en pixelfarve hvis en ray skærer med et objekt i scenen. Funktionen er vist herunder.  

\begin{lstlisting} [style=Cstyle, caption=Funktionen raytracer\_trace]
Pixel raytracer_trace(Ray ray, Scene *scene) {
  Intersection intersection = create_intersection();
  Pixel pixel = {0, 0, 0};
  
  /* If ray intersects with scene: */
  if(raytracer_scene_intersection(ray, scene, &intersection)) {
    /* Shade pixel */
    pixel = raytracer_phong(intersection, scene);
  }
  
  return pixel;
}
\end{lstlisting}
Funktionen initialiserer en skæring med værdien -1 ved at kalde funktionen create\_intersection (linje 2), og en pixel initialiseres til at indeholde RGB-værdien for farven sort (linje 3). Der checkes efterfølgende om den pågældende ray skærer med et objekt i scenen (linje 6), hvis den gør det så tildeles der en RGB-værdi (linje 8), som returneres til sidst i funktionen. 

\paragraph{Skæring med scene}

Funktionen raytracer\_scene\_intersection tjekker om en stråle skærer med et objekt.

\begin{lstlisting}[style=Cstyle, caption=Funktionen raytracer\_scene\_intersection]
int raytracer_scene_intersection(Ray ray, Scene *scene, 
                                 Intersection *intersection) {
  int i;
  Intersection temporary_intersection;

  temporary_intersection = create_intersection();

  /* For each object in scene: */
  for(i = 0; i < scene->n_objects; i++) {
    /* If ray intersects with object: */
    if(raytracer_object_intersection(ray, scene->objects[i], 
       &temporary_intersection))
      /* Reassign intersection if current intersection is closer */
      if(temporary_intersection.t < intersection->t || intersection->t == -1)
        *intersection = temporary_intersection;
  }
  return intersection->t > 0;
}
\end{lstlisting}

If-sætningen på linje 11 assigner temporary\_intersection til en intersection hvis rayen rammer et objekt. If-sætningen på linje 14 sørger for at det er den intersection der er tættest på der bliver sendt tilbage. 


\paragraph{Skæring med objekt}

Funktionen raytracer\_object\_intersection er en funktion, der undersøger om der er en skæring mellem en stråle og et objekt. Funktionen ses herunder:

\begin{lstlisting}[style=Cstyle, caption=raytracer\_object\_intersection]
int raytracer_object_intersection(Ray ray, Object *object, Intersection *intersection) {
  double i, j;
  
  /* if ray intersects with object's aabb: */
  if(intersection_ray_aabb(ray, object->root.box, &i, &j) && 
     raytracer_kdtree_intersection(ray, &(object->root), intersection)) {
    intersection->color = object->color;
    intersection->material = object->material;
  }
  return intersection->t > 0;
}
\end{lstlisting}

På linje fem i ovenstående kodeuddrag kan man se at funktionen tjekker først om lysstrålen skærer med aabb, og hvis dette er sandt tjekker den så om lysstrålen skærer i træet. Hvis begge af disse tilfælde er sande, får pixlen i skæringspunktet en farve bestemt af, hvor og hvordan lysstrålen rammer objektet, samt bliver værdierne af materialet gemt, som kan bruges senere. Herefter returnerer funktionen true, hvis tiden, som beskriver afstanden fra initialpoint til skæringspunktet, er over 0, og false hvis den ikke er.

\paragraph{Skæring med KD-træ}

Funktionen raytracer\_kdtree\_intersection bruges til at undersøge om lysstrålen skærer med kdtræet og i så fald hvor. Formålet med denne funktion er at optimere programmet, og undgå at lave udregninger hvor det ikke er relevant. 

Funktionen kan ses i bilag \ref{sec:...}

Funktionen undersøger først, om skæringen med træet sker i et af bladene. Et blad er 'bunden' af træet, altså det punkt, hvor en kasse ikke længere kan inddeles i flere kasser. Der er tre krav til, hvornår vi ender vores inddeling af flere kasser, og istedet slutter og kalder det for et blad. Første krav er, hvis der er mere end 30 niveauer (DETTE KAN ÆNDRES SENERE  SÅ OPDATER TAL), da vores objekter ikke er alt for avancerede, behøves der ikke mere end 30 niveauer. Det andet krav er, hvis antallet af trekanter i en kasse er mindre end eller lig med 2. En kasse med 2 eller færre trekanter er nemt og hurtigt for computeren at udregne, og derfor behøves den ikke at inddeles yderligere. Det tredje og sidste krav er, hvis over halvdelen af to kassers trekanter ligger i begge kasser. Hvis dette er tilfældet kaldes begge kasser for blade, da mindst halvdelen af begge kassers fælles trekanter er i begge kasser og der derfor ikke er brug for at inddele i flere yderligere kasser.

Hvis roden (hovedkassen) er et blad, findes de nærmeste skæringer først, og der findes skæring med samtlige trekanter, medmindre nogle trekanter ligger helt i skygge for andre.

Hvis roden ikke er et blad og hvis strålen skærer i begge kasser, undersøges hvilken kasse er nærmest og funktionen kaldes rekursivt for denne kasse. Hvis strålen går gennem den nærmeste kasse uden at ramme et objekt tjekkes for den fjerneste kasse. Hvis strålen kun skærer én af kasserne, tjekkes simpelt kun for den kasse.

Funktionen returnerer afstanden i tid, til skæringen med trekanten.

\paragraph{Skæring med trekant}

Funktionen raytracer\_triangle\_intersection bruges til at checke om der er skæring mellem en stråle og en trekant. Funktionen ses herunder

\begin{lstlisting}[style=Cstyle, caption=Funktionen der finder skæring med trekant]
int raytracer_triangle_intersection(Ray ray, Triangle *triangle, Intersection *intersection) {
  double denominator, time;
  Plane plane;
  Vector triangle_normal;
  time = -1;

  triangle_normal = vector_normalize(vector_cross(triangle->edges[0], 
                                                  triangle->edges[1]));

  plane = create_plane(triangle->verticies[0]->position, triangle_normal);

  // If triangle on front of camera: check if point is inside triangle
  if(intersection_ray_plane(ray, plane, &time) && time > 0) {
    int i;
    Vector p = ray_get_point(ray, time);
    for(i = 0; i < VERTICES_IN_TRIANGLE; i++)
      if(vector_dot(triangle_normal, vector_cross(triangle->edges[i], 
         vector_subtract(p, triangle->verticies[i]->position))) < 0)
        return 0;
    intersection->t = time;
    intersection->ray = ray;
    if(vector_dot(ray.direction, triangle_normal) > 0)
      triangle_normal = vector_scale(triangle_normal, -1);
    intersection->normal = triangle_normal;
    return 1;
  }

  return 0;
}
\end{lstlisting}

Funktionen finder en normaliseret normalvektor ud fra to vektorer som beskriver siderne i trekanten (linje 7). Derefter findes trekantens plan ud fra en stedvektor og en normalvektor (linje 10). Der checkes nu om der er skæring mellem trekant og plan (linje 13), hvis der er skæring checkes der om punktet ligger i trekanten (linje 13 - 22). Hvis punktet ligger indenfor trekanten (linje 22) så skaleres der med -1 for, at få normalvektoren til trekanten til at vende ud mod kameraet (linje 23) og værdien gemmes (linje 24).

\paragraph{Phong pixel farve}
Når skæringen er fundet ved ovenstående funktioner, returneres skæringen og tilhørende data gemt i en Intersection til funktionen raytracer\_trace, som kalder raytracer\_phong med scenen og en Intersection, som parametre. prototypen for funktionen er vist herunder.

\begin{lstlisting}[style=Cstyle, caption=prototypen til funktionen der beregner pixelfarven på baggrund af data fra skæring med scenen.]
Pixel raytracer_phong(Intersection intersection, Scene *scene)
\end{lstlisting}

I funktionen raytracer\_phong initialiseres først de variable til phong-modellen, som er beskrevet i afsnit
 \ref{sec:fra_model_til_billede}.

\begin{lstlisting}[style=Cstyle, caption=Initialisering af variabler i raytracer\_phong.] 
m_a = intersection.material.ambient_coefficient;
m_l = intersection.material.diffuse_coefficient;
m_s = intersection.material.specular_coefficient;
m_sp = intersection.material.smoothness;
m_sm = intersection.material.metalness;
vN = intersection.normal;
pC = intersection.color;
pA = scene->ambient_intensity;
diffuse = create_pixel(0.0, 0.0, 0.0);
specular = create_pixel(0.0, 0.0, 0.0);
\end{lstlisting}

Herefter beregnes \textit{ambient} lys efter formlen i udtryk \ref{eq:ambient_formel} under afsnit \ref{sec:fra_model_til_billede}.

\begin{lstlisting}[style=Cstyle, caption=Beregning af ambient lys i raytracer\_phong.] 
ambient = pixel_multiply(pixel_scale(pC, m_a), pA);
\end{lstlisting}

Efter det \textit{ambient} lys, beregnes vektorer til beregning af \textit{diffuse} og \textit{specular} lys.

\begin{lstlisting}[style=Cstyle, caption={Beregning af skæring, vektor $\protect\vv{U}$ og pixel S i raytracer\_phong.}] 
intersection_point = ray_get_point(intersection.ray, intersection.t);
vU = vector_scale(intersection.ray.direction, -1.0);
pS = pixel_add(pixel_scale(pC, m_sm), pixel_scale(create_pixel(1.0, 1.0, 1.0), (1 - m_sm)));
\end{lstlisting}

Via en for-løkke summeres \textit{diffuse} og \textit{specular} lys fra alle lys i scenen, som vist herunder.

\begin{lstlisting}[style=Cstyle, caption=Beregning og summering af diffuse og specular lys fra scenens lys., label=summmering_diffuse_specular]
for(i = 0; i < scene->n_lights; i++) {
  sampled_light_intensity = raytracer_get_light_intensity(scene->lights[i], intersection_point, scene);

  pI = pixel_scale(scene->lights[i]->color, sampled_light_intensity);
  vI = vector_normalize(vector_subtract(scene->lights[i]->position,
                          intersection_point));
  vR = vector_normalize(vector_add(vector_scale(vI, -1),
                        vector_scale(vN, vector_dot(vI, vN) * 2)));

  /* diffuse light =  m_l * MAX(vI * vN, 0) * pC * pI*/
  diffuse = pixel_add(diffuse, pixel_multiply(pixel_scale(pC,
                      m_l * MAX(vector_dot(vI, vN), 0)), pI));

  /* specular light = m_s * MAX(-vR * vU, 0) ^ m_sp * pI * pS */
  specular = pixel_add(specular, pixel_multiply(pS, pixel_scale(pI,
                         m_s * pow(MAX(vector_dot(vR, vU), 0), m_sp))));
}
\end{lstlisting}

I kodeuddrag \ref{summmering_diffuse_specular} linje 2 indlæses intensiteten fra den pågældende lyskilde. Lysintensiteten beregnes i funktionen raytracer\_get\_light\_intensity, ved at teste hvor stor en procentdel af et bestemt antal tilfældige rays fra lyskilden, som ikke afskærmes på vej mod skæringspunktet ved objektet. Dette muliggør bløse skygger, da hver lyskilde kan have en radius, i stedet for blot et bestemt punkt. Ud fra lysintensiteten og lyskildens farve beregnes $I$ (Linje 4). Herefter beregnes $\vv{I}$ og $\vv{R}$, som er hhv. vektor mod lyset og refleksionsvektoren. I linje 11-16, lægges den pågældende lys \textit{diffuse} og \textit{specular} lys til de samlede summer. Til sidst i raytracer\_phong returneres summen af textit{ambient}, \textit{diffuse} og \textit{specular} lys, som er den farve det pågældende skæringspunkt på objektet får, når billedet renderes. 
\begin{lstlisting}[style=Cstyle, caption={summen af ambient, diffuse og specular lys returneres fra raytracer\_phong.}]
/* return ambient + diffuse + specular */
return pixel_add(ambient, pixel_add(diffuse, specular));
\end{lstlisting}

\paragraph{Konvertering fra farvetemperatur til RGB}
Som en ekstra tilføjelse til visualiseringen af lyset fra en lampe, indfører programmet også en funktion, der kan diffierentiere farvetemperaturen af pærens lys. En dybdegående beskrivelse af hvordan en farvetemperatur oversættes til RGB er beskrevet i teoriafsnittet {sec:temptilrgb}. 












